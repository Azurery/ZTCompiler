#include "Token.h"
namespace ztCompiler {
	//symbol table
	const std::unordered_map < std::string, TokenAttr > token::keyword_table{
			{ "char",TokenAttr::CHAR },
			{ "int",TokenAttr::INT },
			{ "switch",TokenAttr::SWITCH },
			{ "float",TokenAttr::FLOAT },
			{ "if",TokenAttr::IF },
			{ "char",TokenAttr::CHAR },
			{ "short",TokenAttr::SHORT },
			{ "double",TokenAttr::DOUBLE },
			{ "long",TokenAttr::LONG },
			{ "else",TokenAttr::ELSE },
			{ "int",TokenAttr::INT },
			{ "signed",TokenAttr::SIGNED },
			{ "unsigned",TokenAttr::UNSIGNED },
			{ "break",TokenAttr::BREAK },
			{ "bool",TokenAttr::BOOL },
			{ "case",TokenAttr::CASE },
			{ "const",TokenAttr::CONST },
			{ "restrict",TokenAttr::RESTRICT },
			{ "do",TokenAttr::DO },
			{"atomic",TokenAttr::ATOMIC},
			{ "volatile",TokenAttr::VOLATILE },
			{ "continue",TokenAttr::CONTINUE },
			{ "default",TokenAttr::DEFAULT },
			{ "while",TokenAttr::WHILE },
			{ "union",TokenAttr::UNION },
			{ "typedef",TokenAttr::TYPEDEF },
			{ "void",TokenAttr::VOID },
			{ "goto",TokenAttr::GOTO },
			{ "extern",TokenAttr::EXTERN },
			{ "auto",TokenAttr::AUTO },
			{ "static_assert",TokenAttr::STATIC_ASSERT },
			{ "thread_local",TokenAttr::THREAD_LOCAL },
	};

	const std::unordered_map<TokenAttr, const char*> token::lexical_table {
		{TokenAttr::IDENTIFIER,"identifier"},
		{ TokenAttr::INT,"int"},
		{ TokenAttr::SHORT,"short"},
		{ TokenAttr::FLOAT,"float"},
		{ TokenAttr::UNSIGNED,"unsigned"},
		{ TokenAttr::LONG,"long"},
		{ TokenAttr::DOUBLE,"double"},
		{ TokenAttr::CHAR,"char"},
		{ TokenAttr::BOOL,"bool"},
		{ TokenAttr::AUTO,"auto" },
		{ TokenAttr::IF,"if" },
		{ TokenAttr::BREAK,"break" },
		{ TokenAttr::INLINE,"inline" },
		{ TokenAttr::CONTINUE,"continue" },
		{ TokenAttr::DEFAULT,"default" },
		{ TokenAttr::DO,"do" },
		{ TokenAttr::ELSE,"else" },
		{ TokenAttr::ENUM,"enum" },
		{ TokenAttr::EXTERN,"extern" },
		{ TokenAttr::FOR,"for" },
		{ TokenAttr::GOTO,"goto" },
		{ TokenAttr::RESTRICT,"restrict" },
		{ TokenAttr::REGISTER,"register" },
		{ TokenAttr::RETURN,"return" },
		{ TokenAttr::SIZEOF,"sizeof" },
		{ TokenAttr::STATIC,"static" },
		{ TokenAttr::STRUCT,"struct" },
		{ TokenAttr::SWITCH,"switch" },
		{ TokenAttr::TYPEDEF,"typedef" },
		{ TokenAttr::UNION,"union" },
		
		{ TokenAttr::PLUS,"+" },
		{ TokenAttr::SUB,"-" },
		{ TokenAttr::MUL,"*" },
		{ TokenAttr::DIV,"/" },
		{ TokenAttr::LESS,"<" },
		{ TokenAttr::GREATER,">" },
		{ TokenAttr::SHARP,"#" },
		{ TokenAttr::DOUBLE_SHARP,"##" },
		{ TokenAttr::DEC,"-" },
		{ TokenAttr::INC,"++" },
		{ TokenAttr::DEREFERENCE,"*" },
		{ TokenAttr::SUB_ASSIGN,"-=" },
		{ TokenAttr::ADD_ASSIGN,"+=" },
		{ TokenAttr::MOD_ASSIGN,"-=" },
		{ TokenAttr::LEFT_SHIFT,"<<" },
		{ TokenAttr::LESS_EQUAL,"<=" },
		{ TokenAttr::RIGHT_SHIFT,">>" },
		{ TokenAttr::GREATER_EQUAL,">=" },
		{ TokenAttr::EQUAL,"=" },
		{ TokenAttr::NOT_EQUAL ,"!=" },
		{ TokenAttr::LOGICAL_AND,"&&" },
		{ TokenAttr::AND_ASSIGN,"&=" },
		{ TokenAttr::LOGICAL_OR,"||" },
		{ TokenAttr::OR_ASSIGN,"|=" },
		{ TokenAttr::INCLUSIVE_OR,"|" },
		{ TokenAttr::EXCLUSIVE_OR,"^" },
		{ TokenAttr::DIV_ASSIGN,"/=" },
		{ TokenAttr::MUL_ASSIGN,"*=" },
		{ TokenAttr::ELLIPSIS,"..." },
	};

}